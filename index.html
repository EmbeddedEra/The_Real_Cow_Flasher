<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>The Real Cow Flasher</title>
    <link rel="stylesheet" type="text/css" href="sakura-dark.css?v=1.0.1" />
    <script src="dfu.js?v=1.0.3"></script>
    <script src="dfuse.js?v=1.0.1"></script>
    <script src="dfu-util.js?v=1.0.1"></script>
    <style>
      p.warning, p.error { color: red; font-weight: bold; }
      label.radio { display: inline; }
      input:invalid { color: red; }
      #changelog { margin-top: 1em; color: #ccc; }
      #localFirmware { margin-left: 10px; }
      .firmware-option { margin-bottom: 8px; }
    </style>
  </head>
  <body>
    <h1>The Real Cow Flasher</h1>
    <button id="connect">Connect</button>
   <button id="helpBtn" style="float:right;">Instructions</button>
    <span id="status" style="margin-left: 1em;"></span>
    <div id="usbInfo" style="white-space: pre"></div>
    <div id="dfuInfo" style="white-space: pre"></div>
    <form id="configForm">
      <fieldset>
        <legend>Firmware</legend>
        <div class="firmware-option">
          <label for="firmwareVersion">Select firmware:</label>
          <select id="firmwareVersion">
            <option>Loading...</option>
          </select>
        </div>
        <div class="firmware-option">
          <label for="localFirmware">Or load from computer:</label>
          <input type="file" id="localFirmware" accept=".bin,.hex,.dfu" />
        </div>
        <button id="download" disabled>Download</button>
        <button id="eraseOnly" disabled>Erase Only</button>
        <div class="log" id="downloadLog"></div>
        <div id="changelog"></div>
      </fieldset>
    </form>
    <script>
      async function populateFirmwareDropdown() {
        try {
          const response = await fetch('firmware.json');
          let files = await response.json();
          // Sort files so latest version appears first
          files.sort((a, b) => {
            // Extract version numbers from filenames like Robot_4.2.0.bin
            const verA = a.match(/(\d+\.\d+\.\d+)/);
            const verB = b.match(/(\d+\.\d+\.\d+)/);
            if (verA && verB) {
              // Compare as [major, minor, patch]
              const pa = verA[1].split('.').map(Number);
              const pb = verB[1].split('.').map(Number);
              for (let i = 0; i < 3; i++) {
                if (pa[i] !== pb[i]) return pb[i] - pa[i];
              }
              return 0;
            }
            // If no version, sort alphabetically
            return b.localeCompare(a);
          });
          const select = document.getElementById('firmwareVersion');
          select.innerHTML = '';
          if (files.length === 0) {
            select.innerHTML = '<option disabled>No firmware files found</option>';
          } else {
            files.forEach(file => {
              const option = document.createElement('option');
              option.value = `Firmware/${file}`;
              option.textContent = file;
              select.appendChild(option);
            });
            // Select the first (latest) firmware by default
            if (select.options.length > 0) {
              select.selectedIndex = 0;
            }
            select.disabled = false;
          }
        } catch (e) {
          console.error('Failed to load firmware list:', e);
          const select = document.getElementById('firmwareVersion');
          select.innerHTML = '<option disabled>Error loading firmware list</option>';
        }
      }

      // Load changelog.json and show entry for selected firmware
      let changelogData = {};
      async function loadChangelog() {
        try {
          const response = await fetch('changelog.json');
          changelogData = await response.json();
        } catch (e) {
          changelogData = {};
        }
      }

      function showChangelogForSelected() {
        const select = document.getElementById('firmwareVersion');
        const changelogDiv = document.getElementById('changelog');
        if (!select || !changelogData) return;
        
        // Make sure we have a valid selection
        if (select.selectedIndex < 0 || !select.options[select.selectedIndex]) {
          changelogDiv.textContent = '';
          return;
        }
        
        const selected = select.options[select.selectedIndex].textContent;
        console.log('Looking for changelog for:', selected, 'in', Object.keys(changelogData));
        
        if (selected && changelogData[selected]) {
          changelogDiv.textContent = 'Changelog: ' + changelogData[selected];
        } else {
          changelogDiv.textContent = '';
        }
      }

      window.addEventListener('DOMContentLoaded', async () => {
        await populateFirmwareDropdown();
        await loadChangelog();
        // Show changelog for the default selected firmware
        showChangelogForSelected();
        document.getElementById('firmwareVersion').addEventListener('change', showChangelogForSelected);
        
        // Handle local file selection
        const localFirmwareInput = document.getElementById('localFirmware');
        const firmwareVersionSelect = document.getElementById('firmwareVersion');
        
        localFirmwareInput.addEventListener('change', (event) => {
          if (event.target.files.length > 0) {
            // Deselect dropdown when local file is chosen
            firmwareVersionSelect.selectedIndex = -1;
            showChangelogForSelected(); // Clear changelog
          }
        });
        
        firmwareVersionSelect.addEventListener('change', () => {
          if (firmwareVersionSelect.selectedIndex >= 0) {
            // Clear local file when dropdown is selected
            localFirmwareInput.value = '';
          }
          showChangelogForSelected();
        });
        
        // Load version from version.json and update footer
        try {
          const response = await fetch('version.json');
          const data = await response.json();
          document.getElementById('versionString').textContent = data.version;
        } catch (e) {
          document.getElementById('versionString').textContent = 'Unknown';
        }

        // Enable/disable erase button based on device connection
        const eraseBtn = document.getElementById('eraseOnly');
        function updateEraseButton() {
          eraseBtn.disabled = !window.device;
        }
        
        // Check device status periodically to update button state
        setInterval(updateEraseButton, 500);
        
        // Also update on page load
        updateEraseButton();

        eraseBtn.addEventListener('click', async () => {
          if (!window.device) {
            alert('No device connected!');
            return;
          }
          eraseBtn.disabled = true;
          const logDiv = document.getElementById('downloadLog');
          logDiv.textContent = 'Starting erase operation...';
          try {
            // First try to clear any existing DFU error state
            try {
              let status = await window.device.getStatus();
              if (status.state === dfu.dfuERROR) {
                await window.device.clearStatus();
                logDiv.textContent = 'Cleared DFU error state, retrying erase...';
              }
            } catch (e) {
              // Ignore status check errors
            }
            
            // Try different erase methods based on device type
            if (window.device.memoryInfo && window.device.erase) {
              // DfuSe device - use the built-in erase method
              let startAddress = window.device.startAddress || window.device.memoryInfo.segments[0].start || 0x08000000;
              let eraseSize = window.device.memoryInfo.segments.reduce((a, s) => a + (s.end - s.start), 0);
              logDiv.textContent = `Erasing ${(eraseSize / 1024).toFixed(0)}KB from address 0x${startAddress.toString(16).toUpperCase()}...`;
              await window.device.erase(startAddress, eraseSize);
              logDiv.textContent = 'Device erase completed successfully!';
              
            } else if (window.device.download) {
              // Standard DFU device - try zero-length download
              try {
                logDiv.textContent = 'Sending DFU erase command...';
                await window.device.download(new ArrayBuffer(0), 0);
                
                // Wait for erase to complete by polling device status
                logDiv.textContent = 'Erasing device... (this may take several seconds)';
                let attempts = 0;
                const maxAttempts = 50; // 25 seconds max
                
                while (attempts < maxAttempts) {
                  try {
                    await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms between polls
                    const status = await window.device.getStatus();
                    
                    if (status.state === dfu.dfuIDLE) {
                      logDiv.textContent = 'Device erase completed successfully!';
                      break;
                    } else if (status.state === dfu.dfuERROR) {
                      throw `Erase failed with DFU error: ${status.string}`;
                    } else if (status.state === dfu.dfuDNBUSY) {
                      logDiv.textContent = `Erasing device... (${Math.round((attempts / maxAttempts) * 100)}% timeout)`;
                    }
                    
                    attempts++;
                  } catch (statusError) {
                    // Some devices don't respond to getStatus during erase, that's normal
                    if (attempts > 10) { // Give it at least 5 seconds
                      logDiv.textContent = 'Erase command sent - device may be completing erase operation.';
                      break;
                    }
                    attempts++;
                  }
                }
                
                if (attempts >= maxAttempts) {
                  logDiv.textContent = 'Erase timeout - operation may still be in progress on device.';
                }
                
              } catch (downloadError) {
                // Zero-length download failed, try alternative methods
                logDiv.textContent = 'Standard DFU erase not supported, trying alternative method...';
                
                // Try using a small dummy write to trigger erase
                if (window.device.startAddress !== undefined) {
                  let dummyData = new ArrayBuffer(4); // 4 bytes of zeros
                  await window.device.download(dummyData, window.device.startAddress || 0x08000000);
                  logDiv.textContent = 'Alternative erase method completed.';
                } else {
                  throw 'Device does not support erase operations via DFU.';
                }
              }
              
            } else {
              throw 'Erase not supported on this device - no erase methods available.';
            }
            
          } catch (e) {
            logDiv.textContent = 'Erase failed: ' + e;
            console.error('Erase error:', e);
            
            // Try to recover device from error state
            try {
              await window.device.clearStatus();
            } catch (clearError) {
              // Ignore clear status errors
            }
          } finally {
            eraseBtn.disabled = false;
          }
        });
      });
    </script>
  </body>
  <footer>
    <div id="version" style="position: fixed; bottom: 8px; right: 16px; color: #aaa; font-size: 0.95em; z-index: 1000;">
      Version: <span id="versionString">Loading...</span>
    </div>
  </footer>
   <script>
     document.getElementById('helpBtn').addEventListener('click', function() {
       window.open('instructions.html', '_blank');
     });
   </script>
</html>
